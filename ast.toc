
;; TODO: make constraints a recursive type when possible

(add-ns c (git-dependency "https://github.com/Toccata-Lang/constraints.git"
                          "constraints.toc"
                          :sha "d1d3464"))

;; we tag symbols with file/line for use later
(defprotocol Tagged
  (namespace [s]
    (assert-result r (instance? (maybe-of Symbol) r)))

  (tag [s]
    (tag s c/no-location))

  (tag [s loc]
    (assert (instance? c/OptionalLoc loc)))

  (location [ast]))

(defprotocol AST
  (syms [_])

  (vars [_]
    (assert-result r (instance? HashMap r))

    (print-err "ast/vars not defined" _LINE_ (type-name _) _)
    (abort)
    {})

  (cond-string-list [ast]
    (string-list ast))

  (var-str [ast]
    (str ast)))

(extend-type Fn
  AST
  (vars [f]
    {}))

(extend-type Vector
  AST
  (vars [v]
    (merge-maps + v)))

(extend-type c/NoSymbol
  Tagged
  (location [_] c/no-location)

  AST
  (syms [_] [])
  (vars [_] {})
  (var-str [s] ""))

(deftype tagged-symbol [ns base sym loc]
  (assert (instance? c/OptionalSym ns))
  (assert (instance? c/OptionalLoc loc))
  (assert (instance? Symbol sym))
  (assert (instance? Symbol base))

  Stringable
  (string-list [s]
    ;; (list "(ast/tagged-symbol " (str ns " " base " " sym " " file " " line "\n" constraint) ")")
    (list (str sym)))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x))

  Hashable
  (sha1 [x] (sha1 sym))

  Ord
  (<* [_ x] (<* x sym))

  Eq
  (=* [ast x]
    (and (=* x sym)
         (maybe ast)))

  AST
  (syms [s] [s])
  (vars [s] {s 1})
  (var-str [_] (str " & " base))

  Tagged
  (location [_] loc)
  (namespace [s] (.ns s))
  (tag [s new-loc] (.loc s new-loc)))

(def OptionalTagged (any-of c/NoSymbol
                            tagged-symbol))

(extend-type Symbol
  Tagged
  (tag [s loc]
    (tagged-symbol c/no-symbol s s loc)))

(deftype block-comment-ast [lines loc]
  (assert (instance? (vector-of String) lines))
  (assert (instance? c/OptionalLoc loc))

  Stringable
  (string-list [_] (comp (list "<BlockCommentAST")
                         (interpose lines "\n")
                         (list ">")))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x))

  Tagged
  (tag [c new-loc]
    (.loc c new-loc))
  (location [x] loc))

(def no-comment (block-comment-ast [] c/no-location))

(defn block-comment [path-to-file line-num lines]
  (block-comment-ast (vec lines) (c/Location path-to-file line-num)))

(deftype integer-ast [int loc]
  (assert (instance? Integer int))
  (assert (instance? c/OptionalLoc loc))

  Stringable
  (string-list [_] (list (str int)))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x))

  AST
  (vars [_] {})

  Tagged
  (tag [n new-loc]
    (.loc n new-loc))
  (location [x] loc))

(deftype params-ast [fixed variadic]
  Stringable
  (string-list [_]
    (comp (list "[")
          (flat-map (interpose fixed " ") string-list)
          (list (var-str variadic) "]")))

  Container
  (map [x f]
    (params-ast (map fixed f) (f variadic)))

  (map [x f embed]
    (for [new-fixed (map fixed f embed)
          new-var (f variadic)]
      (params-ast new-fixed new-var)))

  Collection
  (count [_] (count fixed))

  Tagged
  (tag [ps new-loc]
    (cata (fn [arg]
            (tag arg new-loc))
          ps))

  (location [x]
    (either (map (first fixed) location)
            (location variadic)))

  AST
  (var-str [ps]
    (to-str (cons " & " (string-list ps))))

  (syms [_]
    (comp (flatten fixed) variadic)))

(defn all-syms [params]
  (cata syms params))

(def ParamType (any-of tagged-symbol
                       c/NoSymbol
                       params-ast))

(defn params
  ([fixed] (params-ast fixed c/no-symbol))
  ([fixed variadic]
   ;; TODO: this should be ! (maybe-of ParamType) variadic
   (either (instance? ParamType variadic)
           (do
             (print-err "Compiler error:" _FILE_ _LINE_ "\n" 'variadic variadic)
             (abort)))
   (params-ast fixed variadic)))

(deftype binding-ast [id expr cont]
  Stringable
  (string-list [_]
    (either (map (instance? Vector cont)
                 (fn [_]
                   (list "(let [" (str id) " " (str expr) "]\n" (to-str cont) ")")))
            (do
              (print-err _LINE_ (to-str (list "(let [" (str id) " " (str expr) "]\n"
                                              (str cont) ")")))
              (abort)
              empty-list)))

  Container
  (map [b f]
    (-> b
        (.expr (f expr))
        (.cont (map cont f))))

  (map [b f embed]
    (for [new-expr (f expr)
          new-cont (map cont f embed)]
      (-> b
        (.expr new-expr)
        (.cont new-cont))))

  Tagged
  (location [_]
    (location id))

  AST
  (vars [_]
    (dissoc (reduce cont expr (partial merge-with +))
            id)))

(deftype fn-arity-ast [fn-sym params doc body free-vars]
  (assert (instance? OptionalTagged fn-sym))

  Stringable
  (string-list [_]
    (comp (string-list params)
          (list " " (str free-vars))
          (list "\n")
          (flat-map (interpose body "\n") string-list)))

  ;; (string-list [_]
  ;;   (list "(ast/fn-arity-ast "
  ;;         (str "'" fn-sym) " "
  ;;         (str "'" fn-var) " "
  ;;         (str params) "\n"
  ;;         (str "\"" doc "\"") "\n"
  ;;         (str body) " "
  ;;         ")"))

  Container
  (map [x f]
    (-> x
        (.body (map body f))))

  (map [x f embed]
    (map (map body f embed)
         (partial .body x)))

  AST
  (vars [_]
    (dissoc free-vars fn-sym))

  Tagged
  (tag [f new-loc]
    (cata (fn [ast]
            (tag ast new-loc))
          f))

  (location [_]
    (either (map (first body) location)
            c/no-location)))

(deftype fn-ast [fn-sym arities]
  (assert (instance? OptionalTagged fn-sym))
  (assert (instance? Vector arities))

  Type
  (type-name [x]
    (str "fn-ast: " fn-sym))

  Stringable
  (string-list [_]
    (comp (list "(fn " (cond (instance? tagged-symbol fn-sym)
                             (str fn-sym " ")
                             ""))
          (cond (= 1 (count arities))
                (flat-map (seq arities) string-list)
                (-> (seq arities)
                    (interpose "\n")
                    (flat-map (fn [arity]
                                (comp (list "(")
                                      (string-list arity)
                                      (list ")"))))))
          (list  ")")))

  Container
  (map [x f]
    (.arities x (map arities f)))

  (map [x f embed]
    (-> arities
        (map f embed)
        (map (partial .arities x))))

  AST
  (vars [_]
    (merge-maps + arities))

  Tagged
  (location [_]
    (either (map (first arities) location)
            c/no-location)))

(defn fn-expr [sym arities]
  (fn-ast sym (map arities (fn [arity]
                             (.fn-sym arity sym)))))

(deftype call-ast [call-target args]
  ;; (assert (instance? Vector args))

  Stringable
  (string-list [_]
    (comp (list "(" (str call-target) " ")
          (flat-map (interpose (seq args) " ") string-list)
          (list ")")))

  Container
  (map [x f]
    (call-ast (f call-target) (map args f)))

  (map [x f embed]
    (for [new-target (f call-target)
          new-args (map args f embed)]
      (call-ast new-target new-args)))

  AST
  (vars [ast]
    (merge-maps + (conj args call-target)))

  Tagged
  (location [_]
    (either (map (first args) location)
            (location call-target))))

(defn call-expr [[target & args]]
  (call-ast target (vec args)))

(deftype definition-ast [sym value-exprs]
  (assert (instance? tagged-symbol sym))

  Stringable
  (string-list [_]
    (comp (list "(def " (str sym) "\n")
          (interpose (map value-exprs str) "\n")
          (list ")")))

  Container
  (map [x f]
    (definition-ast sym (map value-exprs f)))

  (map [x f embed]
    (map (map (vec value-exprs) f embed)
         (partial definition-ast sym)))

  Tagged
  (location [_] (location sym)))

(defn definition [sym value]
  (definition-ast sym value))

(def NoCode block-comment-ast)

(defn free-vars [expr]
  ;; (cond (instance? fn-arity-ast expr)
  ;;       (dissoc-all (merge-maps + (map (.body expr) free-vars))
  ;;                   (conj (all-syms (.params expr))
  ;;                         (.fn-sym expr))))

  (cata vars expr))

(defn elgot-env [co-algebra algebra x env]
  (let [[new-x new-env] (co-algebra x env)]
     (cond (instance? RecurseFinal new-x)
           (.x new-x)

           (-> (.x new-x)
               (map (fn [newer-x]
                      (elgot-env co-algebra algebra newer-x new-env)))
               (algebra new-env)))))

(defn simple-replace [expr env]
  (elgot-env (fn [x env]
               (cond (empty? env)
                     [(RecurseFinal x) env]

                     (instance? RecurseFinal x)
                     [x env]

                     (instance? fn-arity-ast x)
                     (cond (empty? (.free-vars x))
                           [(RecurseFinal x) env]

                           (let [new-env (dissoc-all env (all-syms (.params x)))]
                             (cond (empty? new-env)
                                   [(RecurseFinal x) env]

                                   [(RecurseWith x) new-env])))

                     (instance? binding-ast x)
                     (let [new-expr (simple-replace (.expr x) env)
                           new-env (dissoc env (.id x))]
                       (cond (empty? new-env)
                             [(RecurseFinal (.expr x new-expr))
                              env]

                             [(RecurseWith (.expr x (RecurseFinal new-expr)))
                              new-env]))

                     (instance? Fn x)
                     [(RecurseFinal x) env]

                     [(RecurseWith x) env]))
             (fn [x env]
               (either (or (and (instance? tagged-symbol x)
                                (get env x))
                           ;; TODO: pretty big perf hit
                           ;; (map (instance? fn-arity-ast x)
                           ;;      (fn [arity]
                           ;;        (let [body-vars (reduce (map (.body arity) free-vars) {} comp)]
                           ;;          (.free-vars arity (dissoc-all body-vars
                           ;;                                        (all-syms (.params arity)))))))
                           )
                       x))
             expr env))

(defn fn-arity
  ([params doc body]
   (fn-arity c/no-symbol params doc body))
  ([fn-sym params doc body]
   ;; TODO: adequate for lambda calc, but nothing more
   ;; doesn't support destructured or variadic params
   (let [new-params (map (.fixed params) (fn [param]
                                           (assert (instance? tagged-symbol param))
                                           [param (tag (gensym (str param))
                                                       (location param))]))
         env (reduce new-params {} (fn [m [k v]]
                                     (assoc m k v)))
         ;; params (.fixed params (map new-params (fn [[_ p]]
         ;;                                         p)))
         param-syms (all-syms params)
         ;; new-body (simple-replace body env)
         ;; TODO: why does (free-vars new-body) not work
         ;; fvars (merge-maps + (map new-body free-vars))
         ;; dups (reduce param-syms {}
         ;;              (fn [m sym]
         ;;                (either (for [occurs (get fvars sym)
         ;;                              :when (< 1 occurs)]
         ;;                          (assoc m sym (tag (gensym "p") (location sym))))
         ;;                        m)))
         ]
     (fn-arity-ast fn-sym
                   ;; (simple-replace params dups)
                   params
                   doc
                   body
                   ;; (reduce (seq dups) new-body
                   ;;         (fn [bod [dup-sym expr-sym]]
                   ;;           [(binding-ast dup-sym expr-sym bod)]))
                   (-> body
                       (reduce {} (fn [m expr]
                                    (comp m (free-vars expr))))
                       (dissoc-all param-syms))))))

(deftype NestedCond [test clause cont]
  Stringable
  (string-list [_]
    (comp (cons "(cond " (string-list test))
          (cons "\n" (string-list clause))
          (cons "\n\n" (cond-string-list cont))
          (list ")")))

  Container
  (map [x f]
    (-> x
        (.test (f test))
        (.clause (f clause))
        (.cont (f cont))))

  (map [x f embed]
    (for [new-test (f test)
          new-clause (f clause)
          new-cont (f cont)]
      (-> x
        (.test new-test)
        (.clause new-clause)
        (.cont new-cont))))

  AST
  (vars [x]
    (merge-with + test clause cont))

  (cond-string-list [_]
    (comp (string-list test)
          (cons "\n" (string-list clause))
          (cons "\n\n" (cond-string-list cont)))))
