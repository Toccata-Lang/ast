
;; TODO: make constraints a recursive type when possible

(add-ns c (git-dependency "https://github.com/Toccata-Lang/constraints.git"
                          "constraints.toc"
                          :sha "d1d3464"))

;; we tag symbols with file/line for use later
(defprotocol Tagged
  (namespace [s]
    (assert-result r (instance? (maybe-of Symbol) r)))

  (tag [s]
    (tag s c/no-location))

  (tag [s loc]
    (assert (instance? c/OptionalLoc loc)))

  (location [ast]))

(defprotocol AST
  (syms [_])
  (vars [_]
    (assert-result r (instance? HashMap r))

    (print-err 'boom _LINE_ (type-name _) _)
    (abort)
    {})
  (var-str [ast]
    (str ast)))

(extend-type Vector
  AST
  (vars [v]
    (merge-maps + v)))

(extend-type c/NoSymbol
  Tagged
  (location [_] c/no-location)

  AST
  (syms [_] [])
  (vars [_] {})
  (var-str [s] ""))

(deftype tagged-symbol [ns base sym loc]
  (assert (instance? c/OptionalSym ns))
  (assert (instance? c/OptionalLoc loc))
  (assert (instance? Symbol sym))
  (assert (instance? Symbol base))

  Stringable
  (string-list [s]
    ;; (list "(ast/tagged-symbol " (str ns " " base " " sym " " file " " line "\n" constraint) ")")
    (list (str sym)))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x))

  Hashable
  (sha1 [x] (sha1 sym))

  Ord
  (<* [_ x] (<* x sym))

  Eq
  (=* [_ x] (=* x sym))

  AST
  (syms [s] [s])
  (vars [s] {s 1})
  (var-str [_] (str " & " base))

  Tagged
  (location [_] loc)
  (namespace [s] (.ns s))
  (tag [s new-loc] (.loc s new-loc)))

(def OptionalTagged (any-of c/NoSymbol
                            tagged-symbol))

(extend-type Symbol
  Tagged
  (tag [s loc]
    (tagged-symbol c/no-symbol s s loc)))

(deftype block-comment-ast [lines loc]
  (assert (instance? (vector-of String) lines))
  (assert (instance? c/OptionalLoc loc))

  Stringable
  (string-list [_] (comp (list "<BlockCommentAST")
                         (interpose lines "\n")
                         (list ">")))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x))

  Tagged
  (tag [c new-loc]
    (.loc c new-loc))
  (location [x] loc))

(def no-comment (block-comment-ast [] c/no-location))

(defn block-comment [path-to-file line-num lines]
  (block-comment-ast (vec lines) (c/Location path-to-file line-num)))

(deftype integer-ast [int loc]
  (assert (instance? Integer int))
  (assert (instance? c/OptionalLoc loc))

  Stringable
  (string-list [_] (list (str int)))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x))

  AST
  (vars [_] {})

  Tagged
  (tag [n new-loc]
    (.loc n new-loc))
  (location [x] loc))

(deftype params-ast [fixed variadic]
  Stringable
  (string-list [_]
    (comp (list "[")
          (flat-map (interpose fixed " ") string-list)
          (list (var-str variadic) "]")))

  Container
  (map [x f]
    ;; TODO: call 'f' with 'constraint'
    (params-ast (map fixed f) (f variadic)))

  (map [x f embed]
    (for [new-fixed (map fixed f embed)
          new-var (f variadic)]
      (params-ast new-fixed new-var)))

  Collection
  (count [_] (count fixed))

  Tagged
  (tag [ps new-loc]
    (cata (fn [arg]
            (tag arg new-loc))
          ps))

  (location [x]
    (either (map (first fixed) location)
            (location variadic)))

  AST
  (var-str [ps]
    (to-str (cons " & " (string-list ps))))

  (syms [_]
    (comp (flatten fixed) variadic)))

(defn all-syms [params]
  (cata syms params))

(def ParamType (any-of tagged-symbol
                       c/NoSymbol
                       params-ast))

(defn params
  ([fixed] (params-ast fixed c/no-symbol))
  ([fixed variadic]
   ;; TODO: this should be ! (maybe-of ParamType) variadic
   (either (instance? ParamType variadic)
           (do
             (print-err "Compiler error:" _FILE_ _LINE_ "\n" 'variadic variadic)
             (abort)))
   (params-ast fixed variadic)))

(deftype fn-arity-ast [fn-sym params doc body free-vars]
  (assert (instance? OptionalTagged fn-sym))

  Stringable
  (string-list [_]
    (comp (string-list params)
          (list "\n")
          (flat-map (interpose body "\n") string-list)))

  ;; (string-list [_]
  ;;   (list "(ast/fn-arity-ast "
  ;;         (str "'" fn-sym) " "
  ;;         (str "'" fn-var) " "
  ;;         (str params) "\n"
  ;;         (str "\"" doc "\"") "\n"
  ;;         (str body) " "
  ;;         ")"))

  Container
  (map [x f]
    (-> x
        (.body (map body f))))

  (map [x f embed]
    (map (map body f embed)
         (partial .body x)))

  AST
  (vars [_]
    (dissoc-all (merge-maps + body)
                (all-syms params)))

  Tagged
  (tag [f new-loc]
    (cata (fn [ast]
            (tag ast new-loc))
          f))

  (location [_]
    (either (map (first body) location)
            c/no-location)))

(deftype fn-ast [fn-sym arities]
  (assert (instance? OptionalTagged fn-sym))
  (assert (instance? Vector arities))

  Type
  (type-name [x]
    (str "fn-ast: " fn-sym))

  Stringable
  (string-list [_]
    (comp (list "(fn " (cond (instance? tagged-symbol fn-sym)
                             (str fn-sym " ")
                             ""))
          (cond (= 1 (count arities))
                (flat-map (seq arities) string-list)
                (-> (seq arities)
                    (interpose "\n")
                    (flat-map (fn [arity]
                                (comp (list "(")
                                      (string-list arity)
                                      (list ")"))))))
          (list  ")")))

  Container
  (map [x f]
    (fn-ast fn-sym (map arities f)))

  (map [x f embed]
    (-> arities
        (map f embed)
        (map (fn [new-arities]
               (fn-ast fn-sym new-arities)))))

  AST
  (vars [_]
    (merge-maps + arities))

  Tagged
  (location [_]
    (either (map (first arities) location)
            c/no-location)))

(defn fn-expr [sym arities]
  (fn-ast sym arities))

(deftype call-ast [call-target args]
  (assert (instance? Vector args))

  Stringable
  (string-list [_]
    (comp (list "(" (str call-target) " ")
          (flat-map (interpose (seq args) " ") string-list)
          (list ")")))

  Container
  (map [x f]
    (call-ast (f call-target) (map args f)))

  (map [x f embed]
    (for [new-target (f call-target)
          new-args (map args f embed)]
      (call-ast new-target new-args)))

  AST
  (vars [ast]
    (merge-maps + (conj args call-target)))

  Tagged
  (location [_]
    (either (map (first args) location)
            (location call-target))))

(defn call-expr [[target & args]]
  (call-ast target (vec args)))

(deftype definition-ast [sym value-exprs]
  (assert (instance? tagged-symbol sym))

  Stringable
  (string-list [_]
    (comp (list "(def " (str sym) "\n")
          (interpose (map value-exprs str) "\n")
          (list ")")))

  Container
  (map [x f]
    (definition-ast sym (map value-exprs f)))

  (map [x f embed]
    (map (map (vec value-exprs) f embed)
         (partial definition-ast sym)))

  Tagged
  (location [_] (location sym)))

(defn definition [sym value]
  (definition-ast sym value))

(def CodeAST (any-of call-ast
                     fn-ast
                     tagged-symbol))

(def NoCode block-comment-ast)

(defn free-vars [expr]
  (cata vars expr))

(defn fn-arity
  ([params doc body]
   (fn-arity c/no-symbol params doc body))
  ([fn-sym params doc body]
   ;; TODO: adequate for lambda calc, but nothing more
   ;; doesn't support destructured or variadic params
   (let [new-params (map (.fixed params) (fn [param]
                                           (assert (instance? tagged-symbol param))
                                           [param (tag (gensym "p")
                                                       (location param))]))
         env (reduce new-params {} (fn [m [k v]]
                                     (assoc m k v)))
         params (.fixed params (map new-params (fn [[_ p]]
                                                 p)))
         new-body (cata (fn [x]
                          (either (get env x)
                                  x))
                        body)]
     (fn-arity-ast fn-sym params doc new-body
                   (dissoc-all (free-vars new-body)
                               (all-syms params))))))
