
;; TODO: make constraints a recursive type when possible

(add-ns c (git-dependency "https://github.com/Toccata-Lang/constraints.git"
                          "constraints.toc"
                          :sha "93536de"))

(defprotocol FileLoc
  (location [ast]))

(extend-type c/NoValues
  FileLoc
  (location [c] (location (.constraints c))))

(extend-type c/ValueConstraint
  FileLoc
  (location [c]
    (either (last (.path c))
            c/no-loc)))

(extend-type Vector
  FileLoc
  (location [v]
    (print-err 'wut _LINE_ v)
    (abort)
    (either (map (first v) location)
            c/no-loc)))

;; we tag symbols with file/line for use later
(defprotocol Tagged
  (namespace [s]
    (assert-result r (instance? c/OptionalSym r)))

  (tag [s loc]
    (assert (instance? c/Location loc)))

  (tag [s])

  (untag [x]
    (assert-result r (instance? c/OptionalSym r))))

(extend-type c/fn-arity
  FileLoc
  (location [c]
    (location (.param-consts c))))

(extend-type c/NoTail
  FileLoc
  (location [_]
    c/no-loc))

(extend-type c/NoSymbol
  FileLoc
  (location [_]
    c/no-loc)

  Tagged
  (namespace [s]
    s)

  (tag [s loc]
    s)

  (tag [s]
    s)

  (untag [x]
    x))

(deftype Annotated [ast annots]
  Stringable
  (string-list [_]
    (list "^" (str ast)))

  Container
  (map [a f]
    (.ast a (f ast)))

  (map [a f embed]
    (map (f ast) (partial .ast a)))

  FileLoc
  (location [_]
    (location ast)))

(defn annotated [ast]
  (Annotated ast 'annotations))

(deftype tagged-symbol [ns base sym loc constraint]
  (assert (instance? c/Location loc))
  (assert (instance? c/OptionalSym ns))
  (assert (instance? Symbol sym))
  (assert (instance? Symbol base))

  Container
  (map [x f]
    (.constraint x (map (.constraint x) f)))

  (map [x f embed]
    (map (f (.constraint x))
         (partial .constraint x)))

  Hashable
  (sha1 [x] (sha1 base))

  Ord
  (<* [_ x] (<* x base))

  Eq
  (=* [_ x] (=* x base))

  Stringable
  (string-list [s]
    ;; (list "(ast/tagged-symbol " (str ns " " base " " sym " " file " " line "\n" constraint) ")")
    (list (either (map (instance? Symbol (.ns s))
                       (fn [ns-str]
                         (str ns-str "/" (untag (.base s)))))
                  (str (untag (.base s))))))

  FileLoc
  (location [_]
    loc)

  Tagged
  (namespace [s]
    (.ns s))
  (tag [s] s)
  (tag [s new-loc]
    (tagged-symbol (.ns s) (.base s) (.sym s) new-loc c/top-type))
  (untag [s] (.base s))

  c/Constraint
  (c/show-full [x]
    (list (str x))))

(def TaggedSymbol (any-of Symbol
                          tagged-symbol))

(def OptionalTagged (any-of ;; Symbol
                            c/NoSymbol
                            tagged-symbol))

(def no-loc (c/Location "" 0))

(extend-type String
  Tagged
  (tag [s]
    (let [s (symbol s)]
      (tagged-symbol c/no-symbol s s no-loc c/top-type)))
  (tag [s loc]
    (let [s (symbol s)]
      (tagged-symbol c/no-symbol s s loc c/top-type))))

(extend-type Symbol
  Tagged
  (namespace [s]
    s)
  (tag [s]
    (tagged-symbol c/no-symbol s s no-loc c/top-type))
  (tag [s loc]
    (tagged-symbol c/no-symbol s s loc c/top-type))
  (untag [s] s))

(extend-type HashMap
  FileLoc
  (location [m]
    (location (seq m))))

(extend-type Sequence
  FileLoc
  (location [v]
    (either (some v (fn [x]
                      (let [loc (location x)]
                        (cond (= loc no-loc)
                              nothing

                              (maybe loc)))))
            no-loc)))

(def result-sym (tag "#result"))

(deftype inline-ast [lang constraint txt loc]
  (assert (instance? tagged-symbol lang))
  (assert (instance? c/ValueConstraint constraint))
  (assert (instance? String txt))
  (assert (instance? c/Location loc))

  Stringable
  (string-list [_]
    (list "(inline " (str lang) " " (str constraint) " \"" txt "\")"))

  Container
  (map [x f]
    (.constraint x (f constraint)))

  (map [x f embed]
    (map (f constraint)
         (partial .constraint x)))

  FileLoc
  (location [_] loc))

(defn inline [lang txt constraint path-to-file line-num]
  (inline-ast lang txt constraint (c/Location path-to-file line-num)))

(deftype params-ast [fixed variadic constraint]
  ;; (assert (instance? (any-of params-ast c/NoSymbol) variadic))

  Stringable
  (string-list [_]
    (comp (list "[")
          (flat-map (interpose fixed " ") string-list)
          (cond (= c/no-symbol variadic)
                empty-list

                (cons " & " (string-list variadic)))
          (list "]")
          ;; (list " <" (str fixed) " " (str variadic) ">")
          ))

  Container
  (map [x f]
    (params-ast (map fixed f) (f variadic) (f constraint)))

  (map [x f embed]
    (for [new-fixed (map fixed f embed)
          new-var (f variadic)
          new-const (f constraint)]
      (params-ast new-fixed new-var new-const)))

  Collection
  (count [_] (count fixed))

  Tagged
  (tag [_ loc]
    (params-ast (map fixed (fn [x]
                             (tag x loc)))
                (tag variadic loc)
                c/top-type))

  FileLoc
  (location [_]
    (either (map (first fixed) location)
            (location variadic))))

(def ParamType (any-of tagged-symbol
                       params-ast))

(defn params
  ([fixed] (params-ast fixed c/no-symbol c/top-type))
  ([fixed variadic]
   (assert (instance? OptionalTagged variadic))
   (params-ast fixed variadic c/top-type)))

(deftype definition-ast [sym value-exprs]
  (assert (instance? tagged-symbol sym))

  Stringable
  (string-list [_]
    (comp (list "(def " (str sym) "\n")
          (interpose (map value-exprs str) "\n")
          (list ")")))

  Container
  (map [x f]
    (definition-ast sym (map value-exprs f)))

  (map [x f embed]
    (map (map (vec value-exprs) f embed)
         (partial definition-ast sym)))

  FileLoc
  (location [_] (location sym)))

(defn definition [sym value]
  (definition-ast sym value))

(deftype fn-arity-ast [fn-sym fn-var params doc body constraint]
  (assert (instance? OptionalTagged fn-sym))
  (assert (instance? (any-of c/AllValues c/fn-arity) constraint))

  Stringable
  (string-list [_]
    (comp (list (str fn-sym) " ")
          (string-list params)
          (list "\n")
          (flat-map (interpose body "\n") string-list)))

  ;; (string-list [_]
  ;;   (list "(ast/fn-arity-ast "
  ;;         (str "'" fn-sym) " "
  ;;         (str "'" fn-var) " "
  ;;         (str params) "\n"
  ;;         (str "\"" doc "\"") "\n"
  ;;         (str body) " "
  ;;         ")"))

  Container
  (map [x f]
    (-> x
        (.params (f params))
        (.body (map body f))
        (.constraint (f constraint))))

  (map [x f embed]
    (for [new-params (f params)
          new-body (map body f embed)
          new-const (f constraint)]
      (-> x
          (.params new-params)
          (.body new-body)
          (.constraint new-const))))

  FileLoc
  (location [_] (location fn-sym)))

(defn fn-arity
  ([params doc body]
   (fn-arity (tag "") params doc body))
  ([fn-sym params doc body]
   (fn-arity-ast fn-sym "" params doc body c/top-type)))

(deftype fn-ast [fn-sym arities constraint]
  (assert (instance? OptionalTagged fn-sym))
  (assert (instance? Vector arities))

  Type
  (type-name [x]
    (str "fn-ast: " fn-sym "\n" constraint))

  Stringable
  (string-list [_]
    (comp (list "(fn " (str (either (map (instance? tagged-symbol fn-sym)
                                         (fn [s] (str s " ")))
                                    "")))
          (cond (= 1 (count arities))
                (flat-map (seq arities) string-list)
                (-> (seq arities)
                    (interpose "\n")
                    (flat-map (fn [arity]
                                (comp (list "(")
                                      (string-list arity)
                                      (list ")"))))))
          (list  ")")))

  Container
  (map [x f]
    (fn-ast fn-sym (map arities f) (f constraint)))

  (map [x f embed]
    (for [new-arities (map arities f embed)
          new-const (f constraint)]
      (-> x
          (.arities new-arities)
          (.constraint new-const))))

  FileLoc
  (location [_]
    (either (map (first arities) location)
            (location fn-sym))))

(defn fn-expr [sym arities]
  (fn-ast sym arities c/top-type))

(deftype integer-ast [int loc constraint]
  (assert (instance? Integer int))
  (assert (instance? c/Location loc))

  Stringable
  (string-list [_] (list (str int)))

  Container
  (map [x f]
    (.constraint x (f constraint)))

  (map [x f embed]
    (map (f constraint)
         (partial .constraint x)))

  FileLoc
  (location [_] loc))

(deftype string-ast [string loc constraint]
  (assert (instance? String string))
  (assert (instance? c/Location loc))

  Stringable
  (string-list [_] (list "\"" string "\""))

  Container
  (map [x f]
    (.constraint x (f constraint)))

  (map [x f embed]
    (map (f constraint)
         (partial .constraint x)))

  FileLoc
  (location [_] loc))

(deftype block-comment-ast [lines loc constraint]
  (assert (instance? (vector-of String) lines))
  (assert (instance? c/Location loc))

  Stringable
  (string-list [_] (comp (list "<BlockCommentAST")
                         (interpose lines "\n")
                         (list ">")))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x))

  FileLoc
  (location [_] loc))

(defn block-comment [path-to-file line-num lines]
  (block-comment-ast (vec lines) (c/Location path-to-file line-num) c/top-type))

(deftype reify-ast [type-num impls constraint]
  (assert (instance? c/OptionalInt type-num))
  (assert (instance? HashMap impls))

  Stringable
  (string-list [_] (list "(reify " (str type-num " \n" impls) ")"))

  Container
  (map [x f]
    (-> x
        (.impls (map-vals impls (fn [impl-fns]
                                  (map-vals impl-fns (fn [arities]
                                                       (map arities f))))))
        (.constraint (f constraint))))

  (map [x f embed]
    (for [new-impls (contextual-map-vals impls
                                         (fn [impl-fns]
                                           (contextual-map-vals impl-fns
                                                                (fn [arities]
                                                                  (map arities f embed))
                                                                embed))
                                         embed)
          new-const (f constraint)]
      (-> x
          (.impls new-impls)
          (.constraint new-const))))

  FileLoc
  (location [_] (location impls)))

(defn reified [type-num impls]
  (reify-ast type-num impls c/top-type))

(deftype call-ast [call-target args constraint]
  (assert (instance? Vector args))

  Stringable
  (string-list [_]
    (comp (list "(" (str call-target) " ")
          (flat-map (interpose (seq args) " ") string-list)
          (list ")")))

  Container
  (map [x f]
    (call-ast (f call-target) (map args f) (f constraint)))

  (map [x f embed]
    (for [new-target (f call-target)
          new-args (map args f embed)
          new-const (f constraint)]
      (call-ast new-target new-args new-const)))

  FileLoc
  (location [_]
    (cond (first args)
          (location args)
          (location call-target))))

(defn call-expr [[target & args]]
  (call-ast target (vec args) c/top-type))

(deftype quoted-ast [q-val constraint]
  Stringable
  (string-list [_]
    (list (str "'" q-val)))

  Ord
  (<* [x y]
    (assert (instance? quoted-ast y))
    (and (< q-val (.q-val x))
         (maybe x)))

  Container
  (map [x f]
    (quoted-ast (f q-val) (f constraint)))

  (map [x f embed]
    (for [new-v (f q-val)
          new-c (f constraint)]
      (quoted-ast new-v new-c)))

  FileLoc
  (location [_] (location q-val)))

(defn quoted [q-val]
  (quoted-ast q-val c/top-type))

(defprotocol IsCode
  (generates-code? [x]))

(extend-type Annotated
  IsCode
  (generates-code? [a]
    (generates-code? (.ast a))))

(deftype TypeReturned [assertion]
  Stringable
  (string-list [_] (list "(ast/TypeReturned " (str assertion) ")"))

  Container
  (map [x f]
    (.assertion x (f assertion)))

  (map [x f embed]
    (-> assertion
        f
        (map (partial .assertion x))))

  Eq
  (=* [x y]
    (and (instance? TypeReturned y)
         (=* assertion (.assertion y))
         (maybe x))))

(def NoCode (any-of TypeReturned
                    block-comment-ast
                    c/ValueConstraint))

(extend-type NoCode
  IsCode
  (generates-code? [_]
    nothing))

(deftype declaration-ast [sym]
  (assert (instance? tagged-symbol sym))

  Stringable
  (string-list [_] (list "<DeclareAST " (str sym) ">"))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x))

  FileLoc
  (location [_] (location sym)))

(defn declare [sym]
  (declaration-ast sym))

(deftype prototype-ast [fn-name params doc default-body constraint]
  (assert (instance? tagged-symbol fn-name))
  (assert (instance? params-ast params))
  (assert (instance? block-comment-ast doc))
  (assert (instance? Vector default-body))
  (assert (instance? (any-of c/AllValues c/fn-arity) constraint))

  Stringable
  (string-list [_] (comp (list "(" (str fn-name) " ")
                         (string-list params)
                         (list "\n")
                         (flat-map (interpose default-body "\n") string-list)
                         ")"))

  Container
  (map [x f]
    (-> x
        (.params (map params f))
        (.default-body (map default-body f))
        (.constraint (f constraint))))

  (map [x f embed]
    (for [new-params (map params f embed)
          new-body (map default-body f embed)
          new-const (f constraint)]
      (-> x
          (.params new-params)
          (.default-body new-body)
          (.constraint new-const))))

  FileLoc
  (location [_] (location fn-name)))

(defn prototype [fn-name args doc default-body]
  (prototype-ast fn-name args doc default-body c/top-type))

(deftype protocol-ast [protocol-sym prototypes]
  (assert (instance? tagged-symbol protocol-sym))
  (assert (instance? Vector prototypes))

  Stringable
  (string-list [_] (list "(defprotocol " (str protocol-sym) "\n"
                         (to-str (interpose prototypes "\n"))
                         ")"))

  Container
  (map [x f]
    (.prototypes x (map prototypes f)))

  (map [x f embed]
    (map (map prototypes f embed)
         (partial .prototypes x)))

  FileLoc
  (location [_] (location protocol-sym)))

(defn protocol [sym prototypes]
  (protocol-ast sym prototypes))

(deftype extend-ast [type impls]
  (assert (instance? tagged-symbol type))
  (assert (instance? HashMap impls))

  Stringable
  (string-list [_] (list "(extend-type " (str type)
                         "\n" (to-str (interpose impls "\n"))
                         ")"))

  Container
  (map [x f]
    (.impls x (map-vals impls (fn [impl-fns]
                                (map-vals impl-fns (fn [arities]
                                                     (map arities f)))))))

  (map [x f embed]
    (map (contextual-map-vals impls (fn [impl-fns]
                                      (contextual-map-vals impl-fns
                                                           (fn [arities]
                                                             (map arities f embed))
                                                           embed))
                              embed)
         (partial .impls x)))

  FileLoc
  (location [_] (location type)))

(defn type-extension [type impls]
  (extend-ast type (either (map (empty? impls) (fn [_] {}))
                           (apply comp (seq (filter impls (partial instance? HashMap)))))))

;; TODO: make threading into either, and, or possible
(deftype either-ast [clause alt constraint]
  Stringable
  (string-list [_]
    (comp (list "(either ")
          (string-list clause)
          (list "\n")
          (string-list alt)
          (list ")")))

  Container
  (map [x f]
    (either-ast (f clause)
                (f alt)
                (f constraint)))

  (map [x f embed]
    (for [new-clause (f clause)
          new-alt (f alt)
          new-c (f constraint)]
      (either-ast new-clause new-alt new-c)))

  FileLoc
  (location [_] (location clause)))

(defn either-expr [clause alt]
  (either-ast clause alt c/top-type))

(deftype binding-ast [binding val cont constraint]
  Stringable
  (string-list [_]
    (list (str binding) " " (str val)
          "\n" (str cont)))

  Container
  (map [x f]
    (binding-ast (f binding) (f val) (f cont) (f constraint)))

  (map [x f embed]
    (for [new-val (f val)
          new-binding (f binding)
          new-cont (f cont)
          new-const (f constraint)]
      (binding-ast new-binding new-val new-cont new-const)))

  FileLoc
  (location [_] (location val)))

(defn binding [binding val]
  (binding-ast binding val '_ c/top-type))

(defn let-expr [bindings body]
  (-> (reverse bindings)
      (reduce body (fn [cont binding]
                     (.cont binding cont)))))

(deftype and-ast [clause cont types constraint]
  Stringable
  (string-list [_]
    (comp (list "(and " (str clause) "\n")
          (string-list cont)
          (list ")")))

  Container
  (map [x f]
    (-> x
        (.clause (f clause))
        (.cont (f cont))
        (.constraint (f constraint))))

  (map [x f embed]
    (for [new-clause (f clause)
          new-cont (f cont)
          new-c (f constraint)]
      (-> x
          (.clause new-clause)
          (.cont new-cont)
          (.constraint new-c))))

  FileLoc
  (location [_]
    (location clause)))

(defn and-expr [clauses]
  (let [clauses (reverse clauses)]
    (reduce (rest clauses)
            (either (first clauses)
                    (tag 'nothing))
            (fn [cont clause]
              (and-ast clause cont {} c/maybe-constraint)))))

(deftype cond-ast [clause value cont types constraint]
  Stringable
  (string-list [_]
    (list "(cond " (str clause) "\n"
          (str value) "\n"
          (str cont)
          ")"))

  Container
  (map [x f]
    (-> x
        (.clause (f clause))
        (.value (f value))
        (.cont (f cont))
        (.constraint (f constraint))))

  (map [x f embed]
    (for [new-clause (f clause)
          new-value (f value)
          new-cont (f cont)
          new-c (f constraint)]
      (-> x
          (.clause new-clause)
          (.value new-value)
          (.cont new-cont)
          (.constraint new-c))))

  FileLoc
  (location [_]
    (location clause)))

(defn cond-val-expr [clause value]
  (cond-ast clause value (tag '_) {} c/top-type))

(defn cond-expr [clause-vals default]
  (reduce (reverse clause-vals)
          default
          (fn [cont clause-val]
            (.cont clause-val cont))))
