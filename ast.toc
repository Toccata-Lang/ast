
;; TODO: make constraints a recursive type when possible

(add-ns c (git-dependency "https://github.com/Toccata-Lang/constraints.git"
                          "constraints.toc"
                          :sha "d1d3464"))

;; we tag symbols with file/line for use later
(defprotocol Tagged
  (namespace [s]
    (assert-result r (instance? (maybe-of Symbol) r)))

  (tag [s]
    (tag s c/no-location))

  (tag [s loc]
    (assert (instance? c/OptionalLoc loc)))

  (location [ast]))

(defprotocol AST
  (syms [_])

  (prep-replace [x env]
    [(RecurseWith x) env])

  (replace-sym [x env]
    x)

  (vars [_]
    (assert-result r (instance? HashMap r))

    (print-err "ast/vars not defined" _LINE_ (type-name _) _)
    (abort)
    {})

  (cond-string-list [ast]
    (string-list ast))

  (var-str [ast]
    (str ast)))

(defn free-syms [expr]
  (cata vars expr))

(defn elgot-env [co-algebra algebra x env]
  (let [[new-x new-env] (co-algebra x env)]
     (cond (instance? RecurseFinal new-x)
           (.x new-x)

           (-> (.x new-x)
               (map (fn [newer-x]
                      (elgot-env co-algebra algebra newer-x new-env)))
               (algebra new-env)))))

(defn simple-replace [expr env]
  (elgot-env (fn [x env]
               (cond (empty? env)
                     [(RecurseFinal x) env]

                     (prep-replace x env)))
             replace-sym
             expr env))

(extend-type Fn
  AST
  (vars [f]
    {})

  (prep-replace [x env]
    [(RecurseFinal x) env]))

;; (extend-type RecurseFinal
;;   AST
;;   (prep-replace [x env]
;;     [x env]))

(extend-type Vector
  AST
  (vars [v]
    (merge-maps + v)))

(extend-type c/NoSymbol
  Tagged
  (location [_] c/no-location)

  AST
  (syms [_] [])
  (vars [_] {})
  (var-str [s] ""))

(deftype tagged-symbol [ns base sym loc]
  (assert (instance? c/OptionalSym ns))
  (assert (instance? c/OptionalLoc loc))
  (assert (instance? Symbol sym))
  (assert (instance? Symbol base))

  Stringable
  (string-list [s]
    ;; (list "(ast/tagged-symbol " (str ns " " base " " sym " " file " " line "\n" constraint) ")")
    (list (str sym)))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x))

  Hashable
  (sha1 [x] (sha1 sym))

  Ord
  (<* [_ x] (<* x sym))

  Eq
  (=* [ast x]
    (and (=* x sym)
         (maybe ast)))

  AST
  (syms [s] [s])
  (vars [s] {s 1})
  (var-str [_] (str " & " base))
  (replace-sym [x env]
    (either (get env x)
            x))

  Tagged
  (location [_] loc)
  (namespace [s] (.ns s))
  (tag [s new-loc] (.loc s new-loc)))

(def OptionalTagged (any-of c/NoSymbol
                            tagged-symbol))

(deftype param-sym [sym uses]
  (assert (instance? tagged-symbol sym))
  (assert (instance? Integer uses))

  Stringable
  (string-list [s]
    ;; (list "(ast/tagged-symbol " (str ns " " base " " sym " " file " " line "\n" constraint) ")")
    (list (str sym) (str "<" (mod (address-of s) 1000) ">")
          ))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x))

  Hashable
  (sha1 [x] (address-of x))

  Eq
  (=* [ast x]
    (=* (address-of ast)
        (address-of x))
    ;; (identical ast x)
    )

  AST
  (syms [s] [s])
  (vars [s] {s 1})
  (replace-sym [x env]
    (either (get env x)
            x))

  Tagged
  (location [_] (location sym))
  (namespace [s] (namespace sym)))

(extend-type Symbol
  Tagged
  (tag [s loc]
    (tagged-symbol c/no-symbol s s loc)))

(deftype block-comment-ast [lines loc]
  (assert (instance? (vector-of String) lines))
  (assert (instance? c/OptionalLoc loc))

  Stringable
  (string-list [_] (comp (list "<BlockCommentAST")
                         (interpose lines "\n")
                         (list ">")))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x))

  Tagged
  (tag [c new-loc]
    (.loc c new-loc))
  (location [x] loc))

(def no-comment (block-comment-ast [] c/no-location))

(defn block-comment [path-to-file line-num lines]
  (block-comment-ast (vec lines) (c/Location path-to-file line-num)))

(deftype integer-ast [int loc]
  (assert (instance? Integer int))
  (assert (instance? c/OptionalLoc loc))

  Stringable
  (string-list [_] (list (str int)))

  Container
  (map [x f]
    x)

  (map [x f embed]
    (embed x))

  AST
  (vars [_] {})

  Tagged
  (tag [n new-loc]
    (.loc n new-loc))
  (location [x] loc))

(deftype params-ast [fixed variadic]
  Stringable
  (string-list [_]
    (comp (list "[")
          (flat-map (interpose fixed " ") string-list)
          (list (var-str variadic) "]")))

  Container
  (map [x f]
    (params-ast (map fixed f) (f variadic)))

  (map [x f embed]
    (for [new-fixed (map fixed f embed)
          new-var (f variadic)]
      (params-ast new-fixed new-var)))

  Collection
  (count [_] (count fixed))

  Tagged
  (tag [ps new-loc]
    (cata (fn [arg]
            (tag arg new-loc))
          ps))

  (location [x]
    (either (map (first fixed) location)
            (location variadic)))

  AST
  (var-str [ps]
    (to-str (cons " & " (string-list ps))))

  (syms [_]
    (comp (flatten fixed) variadic)))

(defn all-syms [params]
  (cata syms params))

(def ParamType (any-of tagged-symbol
                       param-sym
                       c/NoSymbol
                       params-ast))

(defn params
  ([fixed] (params-ast fixed c/no-symbol))
  ([fixed variadic]
   ;; TODO: this should be ! (maybe-of ParamType) variadic
   (either (instance? ParamType variadic)
           (do
             (print-err "Compiler error:" _FILE_ _LINE_ "\n" 'variadic variadic)
             (abort)))
   (params-ast fixed variadic)))

(defn same-vect [xs ys]
  (or (and (empty? xs) (empty? ys))
      (let [[x & xs] xs
            [y & ys] ys]
        (and (identical x y)
             (same-vect (rest xs) (rest ys))))))

(deftype fn-arity-ast [fn-sym params doc body free-vars]
  (assert (instance? OptionalTagged fn-sym))

  Stringable
  (string-list [_]
    (comp (string-list params)
          ;; (list " " (str free-vars))
          (list "\n")
          (flat-map (interpose body "\n") string-list)))

  ;; (string-list [_]
  ;;   (list "(fn-a "
  ;;         (cond (= fn-sym c/no-symbol)
  ;;               ""
  ;;               (str "'" fn-sym " "))
  ;;         (str params) ;; " " (str free-vars)
  ;;         "\n"
  ;;         ;; (str "\"" doc "\"") "\n"
  ;;         (to-str (flat-map (interpose body "\n") string-list))
  ;;         ")"))

  Container
  (map [x f]
    (let [idxs (int-generator)
          new-body (reduce body body
                           (fn [new-body expr]
                             (let [new-expr (f expr)
                                   idx (extract idxs)]
                               (cond (identical new-expr expr)
                                     new-body
                                     (either (store new-body idx new-expr)
                                             new-body)))))]
      (cond (identical body new-body)
            x
            (.body x (map body f)))))

  (map [x f embed]
    (map (map body f embed)
         (fn [new-body]
           ;; (cond (same-vect body new-body)
           ;;       (do
           ;;         ;; TODO: this ever get called?
           ;;         (print-err 'no-change _LINE_ x)
           ;;         x))
           (.body x new-body))))

  AST
  (vars [_]
    (dissoc free-vars fn-sym))

  (prep-replace [x env]
    (let [new-env (dissoc-all env (all-syms params))]
      (cond (empty? new-env)
            [(RecurseFinal x) env]

            [(RecurseWith x) new-env])))

  Tagged
  (tag [f new-loc]
    (cata (fn [ast]
            (tag ast new-loc))
          f))

  (location [_]
    (either (map (first body) location)
            c/no-location)))

(deftype binding-ast [id expr cont]
  Stringable
  (string-list [_]
    (either (map (instance? Vector cont)
                 (fn [_]
                   (list "(let [" (str id) " " (str expr) "]\n" (to-str cont) ")")))
            (do
              (print-err _LINE_ (to-str (list "(let [" (str id) " " (str expr) "]\n"
                                              (str cont) ")")))
              (abort)
              empty-list)))

  Container
  (map [b f]
    (-> b
        (.expr (f expr))
        (.cont (map cont f))))

  (map [b f embed]
    (for [new-expr (f expr)
          new-cont (map cont f embed)]
      (-> b
          (.expr new-expr)
          (.cont new-cont))))

  Tagged
  (location [_]
    (location id))

  AST
  (prep-replace [x env]
    (let [new-expr (simple-replace expr env)
          new-env (dissoc env id)]
      (cond (empty? new-env)
            [(RecurseFinal (.expr x new-expr))
             env]

            [(RecurseWith (.expr x (RecurseFinal new-expr)))
             new-env])))

  (vars [_]
    (dissoc (reduce cont expr (partial merge-with +))
            id)))

(defn binding-expr [id expr cont]
  (let [fvars (merge-maps + (map cont free-syms))
        ps (param-sym id (either (get fvars id)
                                 0))]
    (binding-ast ps expr (cata (fn [x]
                                 (cond (= x id)
                                       ps
                                       x))
                               cont))))

(deftype fn-ast [fn-sym arities]
  (assert (instance? OptionalTagged fn-sym))
  (assert (instance? Vector arities))

  Type
  (type-name [x]
    (str "fn-ast: " fn-sym))

  Stringable
  (string-list [_]
    (comp (list "(fn " (cond (instance? tagged-symbol fn-sym)
                             (str fn-sym " ")
                             ""))
          (cond (= 1 (count arities))
                (flat-map (seq arities) string-list)
                (-> (seq arities)
                    (interpose "\n")
                    (flat-map (fn [arity]
                                (comp (list "(")
                                      (string-list arity)
                                      (list ")"))))))
          (list  ")")))

  Container
  (map [x f]
    (let [new-arities (map arities f)]
      (cond (same-vect arities new-arities) 
            x
            (.arities x new-arities))))

  (map [x f embed]
    (-> arities
        (map f embed)
        (map (fn [new-arities]
               ;; (cond (same-vect arities new-arities)
               ;;       (do
               ;;         ;; TODO: does this ever get called
               ;;         (print-err 'no-change _LINE_ x)
               ;;         x))
               (.arities x new-arities)))))

  AST
  (vars [_]
    (merge-maps + arities))

  Tagged
  (location [_]
    (either (map (first arities) location)
            c/no-location)))

(defn fn-expr [sym arities]
  (fn-ast sym (map arities (fn [arity]
                             (.fn-sym arity sym)))))

(deftype call-ast [call-target args reduced]
  (assert (instance? Promise reduced))
  ;; (assert (instance? Vector args))

  Stringable
  (string-list [_]
    (comp (list "(" (str call-target) " ")
          (flat-map (interpose (seq args) " ") string-list)
          (list ;; (str " " (mod (address-of _) 1000))
                ")")))

  Container
  (map [x f]
    (let [new-target (f call-target)
          arg-idxs (int-generator)
          new-args (reduce args args
                           (fn [new-args arg]
                             (let [new-arg (f arg)
                                   arg-idx (extract arg-idxs)]
                               (cond (identical new-arg arg)
                                     new-args
                                     (either (store new-args arg-idx new-arg)
                                             new-args)))))]
      (cond (and (identical call-target new-target)
                 (identical args new-args))
            x
            (call-ast new-target new-args (promise)))))

  (map [x f embed]
    (for [new-target (f call-target)
          new-args (map args f embed)]
      ;; (cond (and (identical call-target new-target)
      ;;            (same-vect args new-args))
      ;;       (do
      ;;         ;; TODO: does this ever get called?
      ;;         (print-err 'no-change _LINE_ x)
      ;;         x))
      (call-ast new-target new-args (promise))))

  AST
  (vars [ast]
    (merge-maps + (conj args call-target)))

  Tagged
  (location [_]
    (either (map (first args) location)
            (location call-target))))

(defn call-expr [[target & args]]
  (call-ast target (vec args) (promise)))

(deftype definition-ast [sym value-exprs]
  (assert (instance? tagged-symbol sym))

  Stringable
  (string-list [_]
    (comp (list "(def " (str sym) "\n")
          (interpose (map value-exprs str) "\n")
          (list ")")))

  Container
  (map [x f]
    (definition-ast sym (map value-exprs f)))

  (map [x f embed]
    (map (map (vec value-exprs) f embed)
         (partial definition-ast sym)))

  Tagged
  (location [_] (location sym)))

(defn definition [sym value]
  (definition-ast sym value))

(def NoCode block-comment-ast)

(defn fn-arity
  ([params doc body]
   (fn-arity c/no-symbol params doc body))
  ([fn-sym params doc body]
   ;; TODO: adequate for lambda calc, but nothing more
   ;; doesn't support destructured or variadic params
   (let [fvars (merge-maps + (map body free-syms))
         param-syms (all-syms params)
         dups (reduce param-syms {}
                      (fn [m sym]
                        (assoc m sym (param-sym sym (either (get fvars sym)
                                                            0)))))
         fvars (dissoc-all fvars param-syms)]
     (fn-arity-ast fn-sym
                   (cata (fn [s]
                           (either (get dups s)
                                   s))
                         params)
                   doc
                   (cata (fn [s]
                           (either (get dups s)
                                   s))
                         body)
                   fvars))))

(deftype NestedCond [test clause cont]
  Stringable
  (string-list [_]
    (comp (cons "(cond " (string-list test))
          (cons "\n" (string-list clause))
          (cons "\n\n" (cond-string-list cont))
          (list ")")))

  Container
  (map [x f]
    (-> x
        (.test (f test))
        (.clause (f clause))
        (.cont (f cont))))

  (map [x f embed]
    (for [new-test (f test)
          new-clause (f clause)
          new-cont (f cont)]
      (-> x
        (.test new-test)
        (.clause new-clause)
        (.cont new-cont))))

  AST
  (vars [x]
    (merge-with + test clause cont))

  (cond-string-list [_]
    (comp (string-list test)
          (cons "\n" (string-list clause))
          (cons "\n\n" (cond-string-list cont)))))
